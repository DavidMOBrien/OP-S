{% extends "base.html" %}

{% block title %}Character Charts - One Piece Character Tracker{% endblock %}

{% block head %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
{% endblock %}

{% block content %}
<div class="container">
    <h1>Character Value Charts</h1>

    {% if message %}
    <div class="no-data">
        <h2>No Character Data Available</h2>
        <p>{{ message }}</p>
    </div>
    {% elif characters %}
    <div class="charts-controls">
        <div class="character-selection">
            <h3>Select Characters to Compare</h3>
            <div class="character-selector">
                <input type="text" id="character-search" placeholder="Search characters..." />
                <div class="character-checkboxes" id="character-checkboxes">
                    {% for character in characters %}
                    <label class="character-checkbox" data-name="{{ character.name|lower }}">
                        <input type="checkbox" value="{{ character.wiki_url }}" data-name="{{ character.name }}">
                        <span class="checkbox-label">{{ character.name }} ({{ character.current_value }})</span>
                    </label>
                    {% endfor %}
                </div>
            </div>

            <div class="selection-controls">
                <button type="button" id="select-all" class="btn btn-secondary">Select All</button>
                <button type="button" id="clear-all" class="btn btn-secondary">Clear All</button>
                <button type="button" id="select-top-10" class="btn btn-secondary">Top 10</button>
            </div>
        </div>

        <div class="chart-options">
            <h3>Chart Options</h3>
            <div class="option-group">
                <label for="show-points">Show Data Points:</label>
                <input type="checkbox" id="show-points" checked>
            </div>

            <div class="option-group">
                <label for="smooth-lines">Smooth Lines:</label>
                <input type="checkbox" id="smooth-lines">
            </div>
        </div>
    </div>

    <div class="chart-container">
        <canvas id="character-chart"></canvas>
    </div>

    <div class="selected-characters" id="selected-characters">
        <h3>Selected Characters</h3>
        <div class="selected-list" id="selected-list">
            <p class="no-selection">No characters selected. Choose characters above to see their value history.</p>
        </div>
    </div>

    {% else %}
    <div class="no-data">
        <h2>No Character Data Available</h2>
        <p>It looks like the data gathering script hasn't been run yet.</p>
        <p>Run the Python script to populate the database with character information.</p>
    </div>
    {% endif %}
</div>
{% endblock %}

{% block scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function () {
        const characterCheckboxes = document.querySelectorAll('.character-checkbox input[type="checkbox"]');
        const characterSearch = document.getElementById('character-search');
        const selectAllBtn = document.getElementById('select-all');
        const clearAllBtn = document.getElementById('clear-all');
        const selectTop10Btn = document.getElementById('select-top-10');

        const showPointsCheckbox = document.getElementById('show-points');
        const smoothLinesCheckbox = document.getElementById('smooth-lines');
        const selectedList = document.getElementById('selected-list');
        const chartCanvas = document.getElementById('character-chart');

        let chart = null;
        let characterData = new Map(); // Cache for character history data
        let allCharacterHistories = new Map(); // Store all character data for cross-referencing

        // Initialize Chart.js
        function initChart() {
            const ctx = chartCanvas.getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    onHover: (event, activeElements) => {
                        // Custom hover handler to ensure all lines are hoverable
                        event.native.target.style.cursor = activeElements.length > 0 ? 'pointer' : 'default';
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Character Value History'
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            filter: function(tooltipItem) {
                                // Only show tooltip items for characters that have actual activity at this chapter
                                return tooltipItem.raw && tooltipItem.raw.hasActivity === true;
                            },
                            callbacks: {
                                title: function (context) {
                                    if (context.length === 0) return '';
                                    const chapter = context[0].parsed.x;
                                    return 'Chapter ' + chapter;
                                },
                                beforeBody: function(context) {
                                    if (context.length === 0) return [];
                                    
                                    const chapter = context[0].parsed.x;
                                    const activeCharacters = [];
                                    
                                    // Find all characters with activity in this chapter
                                    allCharacterHistories.forEach((history, characterName) => {
                                        const chapterData = history.find(point => point.chapter === chapter);
                                        if (chapterData && chapterData.change !== 0) {
                                            activeCharacters.push({
                                                name: characterName,
                                                data: chapterData
                                            });
                                        }
                                    });
                                    
                                    if (activeCharacters.length > 1) {
                                        return [`${activeCharacters.length} characters active in this chapter:`];
                                    }
                                    return [];
                                },
                                label: function (context) {
                                    const change = context.raw.change || 0;
                                    const changeText = change > 0 ? `(+${change})` : change < 0 ? `(${change})` : '';
                                    return `${context.dataset.label}: ${context.parsed.y} ${changeText}`;
                                },
                                afterLabel: function (context) {
                                    const reasoning = context.raw.reasoning || '';
                                    if (!reasoning) return [];
                                    
                                    // Split long text into multiple lines for better readability
                                    const maxLineLength = 50;
                                    const words = reasoning.split(' ');
                                    const lines = [];
                                    let currentLine = '';
                                    
                                    words.forEach(word => {
                                        if ((currentLine + word).length <= maxLineLength) {
                                            currentLine += (currentLine ? ' ' : '') + word;
                                        } else {
                                            if (currentLine) lines.push(currentLine);
                                            currentLine = word;
                                        }
                                    });
                                    if (currentLine) lines.push(currentLine);
                                    
                                    return lines;
                                }
                            },
                            bodyFont: {
                                size: 11
                            },
                            titleFont: {
                                size: 13,
                                weight: 'bold'
                            },
                            padding: 12,
                            cornerRadius: 6,
                            displayColors: true,
                            maxWidth: 400,
                            multiKeyBackground: 'rgba(0,0,0,0.8)'
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Chapter'
                            },
                            type: 'linear'
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Character Value'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // Generate random color for character line
        function generateColor(index) {
            const colors = [
                '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
                '#FF9F40', '#FF6384', '#C9CBCF', '#4BC0C0', '#FF6384',
                '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40'
            ];
            return colors[index % colors.length];
        }

        // Fetch character history data
        async function fetchCharacterHistory(wikiUrl) {
            if (characterData.has(wikiUrl)) {
                return characterData.get(wikiUrl);
            }

            try {
                const response = await fetch(`/api/character/${encodeURIComponent(wikiUrl)}/history`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                characterData.set(wikiUrl, data);
                return data;
            } catch (error) {
                console.error('Error fetching character history:', error);
                return null;
            }
        }



        // Update chart with selected characters
        async function updateChart() {
            const selectedCheckboxes = Array.from(characterCheckboxes).filter(cb => cb.checked);

            if (selectedCheckboxes.length === 0) {
                chart.data.datasets = [];
                allCharacterHistories.clear();
                chart.update();
                return;
            }

            const datasets = [];
            allCharacterHistories.clear();
            
            // First, collect all character data
            const characterHistories = new Map();
            
            for (let i = 0; i < selectedCheckboxes.length; i++) {
                const checkbox = selectedCheckboxes[i];
                const wikiUrl = checkbox.value;
                const characterName = checkbox.dataset.name;

                const historyData = await fetchCharacterHistory(wikiUrl);
                if (!historyData || !historyData.history) continue;

                characterHistories.set(characterName, {
                    history: historyData.history,
                    color: generateColor(i)
                });
                
                // Store for tooltip cross-referencing
                allCharacterHistories.set(characterName, historyData.history);
            }

            // Create unified timeline with all chapters where ANY character has activity
            const allChapters = new Set();
            characterHistories.forEach((data) => {
                data.history.forEach(point => {
                    allChapters.add(point.chapter);
                });
            });
            
            const sortedChapters = Array.from(allChapters).sort((a, b) => a - b);

            // Create datasets with unified timeline
            characterHistories.forEach((data, characterName) => {
                const chartData = [];
                let currentValue = 0;
                let characterStarted = false;
                
                // Find the character's first appearance (when they first have a value > 0)
                const firstAppearance = data.history.find(point => point.value > 0);
                const startChapter = firstAppearance ? firstAppearance.chapter : sortedChapters[0];
                
                // Build complete timeline for this character
                for (const chapter of sortedChapters) {
                    const historyPoint = data.history.find(point => point.chapter === chapter);
                    
                    if (historyPoint) {
                        // Character has activity in this chapter
                        currentValue = historyPoint.value;
                        characterStarted = true;
                        chartData.push({
                            x: chapter,
                            y: currentValue,
                            change: historyPoint.change,
                            reasoning: historyPoint.reasoning,
                            characterName: characterName,
                            hasActivity: true
                        });
                    } else {
                        // Character has no activity in this chapter
                        if (chapter >= startChapter) {
                            // Character exists at this point, show their current value
                            if (!characterStarted && chapter === startChapter) {
                                // This is their starting point
                                currentValue = firstAppearance ? firstAppearance.value : 0;
                                characterStarted = true;
                            }
                            
                            chartData.push({
                                x: chapter,
                                y: currentValue,
                                change: 0,
                                reasoning: `No activity in Chapter ${chapter}`,
                                characterName: characterName,
                                hasActivity: false
                            });
                        } else {
                            // Character doesn't exist yet, but we still need a data point for perfect alignment
                            chartData.push({
                                x: chapter,
                                y: 0,
                                change: 0,
                                reasoning: `${characterName} not yet introduced`,
                                characterName: characterName,
                                hasActivity: false
                            });
                        }
                    }
                }

                datasets.push({
                    label: characterName,
                    data: chartData,
                    borderColor: data.color,
                    backgroundColor: data.color + '20',
                    fill: false,
                    tension: smoothLinesCheckbox.checked ? 0.4 : 0,
                    pointRadius: showPointsCheckbox.checked ? 4 : 0,
                    pointHoverRadius: 6,
                    spanGaps: true
                });
            });

            chart.data.datasets = datasets;
            chart.options.plugins.title.text = `Character Value History (${selectedCheckboxes.length} character${selectedCheckboxes.length !== 1 ? 's' : ''})`;
            chart.update();
        }

        // Update selected characters list
        function updateSelectedList() {
            const selectedCheckboxes = Array.from(characterCheckboxes).filter(cb => cb.checked);

            if (selectedCheckboxes.length === 0) {
                selectedList.innerHTML = '<p class="no-selection">No characters selected. Choose characters above to see their value history.</p>';
                return;
            }

            const selectedItems = selectedCheckboxes.map((checkbox, index) => {
                const color = generateColor(index);
                return `
                <div class="selected-character">
                    <span class="color-indicator" style="background-color: ${color}"></span>
                    <span class="character-name">${checkbox.dataset.name}</span>
                    <button type="button" class="remove-character" data-wiki-url="${checkbox.value}">×</button>
                </div>
            `;
            }).join('');

            selectedList.innerHTML = selectedItems;

            // Add remove functionality
            selectedList.querySelectorAll('.remove-character').forEach(btn => {
                btn.addEventListener('click', function () {
                    const wikiUrl = this.dataset.wikiUrl;
                    const checkbox = document.querySelector(`input[value="${wikiUrl}"]`);
                    if (checkbox) {
                        checkbox.checked = false;
                        updateSelectedList();
                        updateChart();
                    }
                });
            });
        }

        // Search functionality
        function filterCharacters() {
            const searchTerm = characterSearch.value.toLowerCase();
            const checkboxLabels = document.querySelectorAll('.character-checkbox');

            checkboxLabels.forEach(label => {
                const name = label.dataset.name;
                if (searchTerm === '' || name.includes(searchTerm)) {
                    label.style.display = '';
                } else {
                    label.style.display = 'none';
                }
            });
        }



        // Event listeners
        characterCheckboxes.forEach(checkbox => {
            checkbox.addEventListener('change', function () {
                updateSelectedList();
                updateChart();
            });
        });

        characterSearch.addEventListener('input', filterCharacters);

        selectAllBtn.addEventListener('click', function () {
            const visibleCheckboxes = Array.from(characterCheckboxes).filter(cb =>
                cb.closest('.character-checkbox').style.display !== 'none'
            );
            visibleCheckboxes.forEach(cb => cb.checked = true);
            updateSelectedList();
            updateChart();
        });

        clearAllBtn.addEventListener('click', function () {
            characterCheckboxes.forEach(cb => cb.checked = false);
            updateSelectedList();
            updateChart();
        });

        selectTop10Btn.addEventListener('click', function () {
            // Clear all first
            characterCheckboxes.forEach(cb => cb.checked = false);

            // Select first 10 visible characters (they're already sorted by value desc)
            const visibleCheckboxes = Array.from(characterCheckboxes).filter(cb =>
                cb.closest('.character-checkbox').style.display !== 'none'
            ).slice(0, 10);

            visibleCheckboxes.forEach(cb => cb.checked = true);
            updateSelectedList();
            updateChart();
        });



        showPointsCheckbox.addEventListener('change', function () {
            chart.data.datasets.forEach(dataset => {
                dataset.pointRadius = this.checked ? 4 : 0;
            });
            chart.update();
        });

        smoothLinesCheckbox.addEventListener('change', function () {
            chart.data.datasets.forEach(dataset => {
                dataset.tension = this.checked ? 0.4 : 0;
            });
            chart.update();
        });

        // Initialize
        initChart();
        updateSelectedList();
    });
</script>
{% endblock %}